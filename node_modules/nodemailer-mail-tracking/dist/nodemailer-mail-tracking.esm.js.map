{"version":3,"file":"nodemailer-mail-tracking.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/lib/split-recipients.ts","../src/lib/jwt.ts","../src/lib/patch-html.ts","../src/send-mail.ts","../src/express-middleware.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {\n  SendMailOptions,\n  SendMailOptionsWithHtml,\n  SendMailOptionsPatched,\n  IRecipient,\n} from '../types';\n\nconst recipientKeys = ['to', 'cc', 'bcc'];\n\nexport const splitByRecipients = (\n  options: SendMailOptionsWithHtml\n): SendMailOptionsPatched[] => {\n  return recipientKeys\n    .map(\n      recipientKey =>\n        options[recipientKey as keyof typeof options] as IRecipient\n    )\n    .map(recipient => patchSendMailOptions(recipient, options))\n    .flat()\n    .filter(<T>(n?: T): n is T => Boolean(n));\n};\n\nconst joinRecipients = (recipients: string | string[]) =>\n  Array.isArray(recipients) ? recipients.join(', ') : recipients;\n\nconst patchSendMailOptions = (\n  recipient: IRecipient,\n  { to, cc, bcc, ...options }: SendMailOptionsWithHtml\n): SendMailOptionsPatched[] | undefined => {\n  const headers: SendMailOptions['headers'] = {};\n  const toAddress = getRecipientAddress(to);\n  if (toAddress) {\n    headers.To = joinRecipients(toAddress);\n  }\n  const ccAddress = getRecipientAddress(cc);\n  if (ccAddress) {\n    headers.Cc = joinRecipients(ccAddress);\n  }\n  const bccAddress = getRecipientAddress(bcc);\n  if (bccAddress) {\n    headers.Bcc = joinRecipients(bccAddress);\n  }\n\n  const from = getRecipientAddress(options.from);\n  const rcptTo = toArrayString(getRecipientAddress(recipient)) || [];\n\n  return rcptTo.map(recipient => ({\n    ...options,\n    headers: {\n      ...options.headers,\n      ...headers,\n    },\n    envelope: {\n      from: Array.isArray(from) ? from[0] : from,\n      to: recipient,\n    },\n  }));\n};\n\nfunction getRecipientAddress(\n  recipient: IRecipient\n): string | string[] | undefined {\n  return typeof recipient === 'string'\n    ? recipient\n    : Array.isArray(recipient)\n    ? recipient\n        .map(r => {\n          return typeof r === 'string'\n            ? r\n            : ((r as any).address as string) || undefined;\n        })\n        .filter(<T>(n?: T): n is T => Boolean(n))\n    : recipient?.address\n    ? recipient.address\n    : undefined;\n}\n\nfunction toArrayString(value?: string | string[]): string[] | undefined {\n  return typeof value === 'undefined' || Array.isArray(value) ? value : [value];\n}\n","import jwt from 'jsonwebtoken';\nimport { JwtData, MailTrackOptions } from '../types';\n\nexport type JwtOptions = Pick<MailTrackOptions, 'jwtSecret'>;\n\nexport const sign = (options: JwtOptions, data: JwtData) => {\n  return jwt.sign(\n    {\n      ...data,\n    },\n    options.jwtSecret,\n    { expiresIn: '1y' }\n  );\n};\n\nexport const decode = (options: JwtOptions, token: string) => {\n  try {\n    return jwt.verify(token, options.jwtSecret);\n  } catch (originalError) {\n    const err = new Error('JwtDecodeError');\n    err.name = 'JwtDecodeError';\n    throw err;\n  }\n};\n\nexport function isDecodeError(error: any) {\n  return error && 'name' in error && error.name === 'JwtDecodeError';\n}\n","import { load } from 'cheerio';\nimport { sign, JwtOptions } from './jwt';\nimport { JwtData, JwtDataForLink, MailTrackOptions } from '../types';\n\nexport const addBlankImage = (\n  options: Pick<MailTrackOptions, 'baseUrl' | 'imageAlt'> & JwtOptions,\n  html: string,\n  data: JwtData\n) => {\n  const jwtImg = sign(options, data);\n  const imgTag = `<img src=\"${options.baseUrl}/blank-image/${encodeURI(\n    jwtImg\n  )}\"${options.imageAlt ? ` alt=\"${options.imageAlt}\"` : ''} />`;\n  if (new RegExp(/<\\/body>/).test(html)) {\n    html = html.replace(/<\\/body>/, `${imgTag}</body>`);\n  } else {\n    html = `${html}${imgTag}`;\n  }\n\n  return html;\n};\n\nexport const patchLinks = (\n  options: Pick<MailTrackOptions, 'baseUrl'> & JwtOptions,\n  html: string,\n  data: JwtData\n) => {\n  const $ = load(html);\n  $('a').each((_, el) => {\n    const href = $(el).attr('href');\n    if (href && href.startsWith('http')) {\n      const jwtData: JwtDataForLink = {\n        ...data,\n        link: href,\n      };\n      const jwtLink = sign(options, jwtData);\n      $(el).attr('href', `${options.baseUrl}/link/${encodeURI(jwtLink)}`);\n    }\n  });\n  return $.html();\n};\n","import { Transporter, SentMessageInfo } from 'nodemailer';\nimport pMap from 'p-map';\nimport {\n  SendMailOptions,\n  SendMailOptionsWithHtml,\n  MailTrackOptionsSendMail,\n  JwtData,\n  SendMailOptionsPatched,\n} from './types';\nimport { splitByRecipients } from './lib/split-recipients';\nimport { addBlankImage, patchLinks } from './lib/patch-html';\n\nfunction isMailOptionsWithHtml(v: any): v is SendMailOptionsWithHtml {\n  return v.html && typeof v.html === 'string';\n}\n\ntype SendMailResult = {\n  result?: SentMessageInfo;\n  error?: any;\n  sendOptions: SendMailOptions | SendMailOptionsPatched;\n};\n\nexport const sendMail = async (\n  options: MailTrackOptionsSendMail,\n  transporter: Transporter,\n  sendMailOptions: SendMailOptions\n): Promise<SendMailResult[]> => {\n  if (!isMailOptionsWithHtml(sendMailOptions)) {\n    try {\n      if (options.getSendOptionsBeforeSend) {\n        sendMailOptions = await options.getSendOptionsBeforeSend(\n          sendMailOptions as SendMailOptionsPatched\n        );\n      }\n      const result: SentMessageInfo = await transporter.sendMail(\n        sendMailOptions\n      );\n      return [\n        {\n          result: result,\n          sendOptions: sendMailOptions,\n        },\n      ];\n    } catch (error) {\n      return [\n        {\n          error,\n          sendOptions: sendMailOptions,\n        },\n      ];\n    }\n  }\n  const sendOptions = getSendOptions(options, sendMailOptions);\n  return pMap(\n    sendOptions,\n    async sendOptions => {\n      try {\n        if (options.getSendOptionsBeforeSend) {\n          sendOptions = await options.getSendOptionsBeforeSend(sendOptions);\n        }\n        const result = await transporter.sendMail(sendOptions);\n        return {\n          result,\n          sendOptions: sendOptions,\n        };\n      } catch (error) {\n        return {\n          error,\n          sendOptions: sendOptions,\n        };\n      }\n    },\n    {\n      concurrency: options.sendConcurrency || Infinity,\n    }\n  );\n};\n\nconst getSendOptions = (\n  options: MailTrackOptionsSendMail,\n  sendMailOptions: SendMailOptionsWithHtml\n): SendMailOptionsPatched[] => {\n  return splitByRecipients(sendMailOptions).map(o => {\n    const data = {\n      recipient:\n        typeof o.envelope.to === 'object'\n          ? o.envelope.to.address\n          : extractEmails(o.envelope.to),\n    };\n    const tokenData = {\n      ...options.getData(data),\n      ...data,\n    };\n    return {\n      ...o,\n      html: patchHtmlBody(options, o.html, tokenData),\n    };\n  });\n};\n\nconst patchHtmlBody = (\n  options: MailTrackOptionsSendMail,\n  html: string,\n  data: JwtData\n) => {\n  return patchLinks(options, addBlankImage(options, html, data), data).trim();\n};\n\nexport const extractEmails = (text: string) => {\n  // d\\+1 = \"+\"\n  const result = text.match(\n    /([a-zA-Z0-9._-]+[d+1]?[a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\\.[a-zA-Z0-9_-]+)/gi\n  );\n  return (result && result[0]) || '';\n};\n","import express from 'express';\nimport { MailTrackOptionsMiddleware, JwtData, JwtDataForLink } from './types';\nimport { decode, isDecodeError } from './lib/jwt';\n\nconst image = `<?xml version=\"1.0\" encoding=\"UTF-8\"?><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"1\" height=\"1\"/>`;\n\nexport function expressApp(\n  getOptions:\n    | MailTrackOptionsMiddleware\n    | Promise<MailTrackOptionsMiddleware>\n    | (() => Promise<MailTrackOptionsMiddleware>)\n) {\n  const app = express();\n\n  const resolveOptions = () =>\n    Promise.resolve(\n      typeof getOptions === 'function' ? getOptions() : getOptions\n    );\n\n  app.get('/link/:jwt', async (req, res, next) => {\n    try {\n      const options = await resolveOptions();\n      const data = decode(options, req.params.jwt) as JwtDataForLink;\n      await options.onLinkClick(data);\n      res.redirect(data.link);\n    } catch (err) {\n      if (isDecodeError(err)) {\n        next();\n      } else {\n        next(err);\n      }\n    }\n  });\n\n  app.get('/blank-image/:jwt', async (req, res, next) => {\n    try {\n      const options = await resolveOptions();\n      const data = decode(options, req.params.jwt) as JwtData;\n      await options.onBlankImageView(data);\n      res.set('Content-Type', 'image/svg+xml');\n      res.send(image);\n    } catch (err) {\n      if (isDecodeError(err)) {\n        next();\n      } else {\n        next(err);\n      }\n    }\n  });\n\n  return app;\n}\n"],"names":["recipientKeys","splitByRecipients","options","map","recipientKey","recipient","patchSendMailOptions","flat","filter","n","Boolean","joinRecipients","recipients","Array","isArray","join","to","cc","bcc","headers","toAddress","getRecipientAddress","To","ccAddress","Cc","bccAddress","Bcc","from","rcptTo","toArrayString","envelope","r","address","undefined","value","sign","data","jwt","jwtSecret","expiresIn","decode","token","verify","originalError","err","Error","name","isDecodeError","error","addBlankImage","html","jwtImg","imgTag","baseUrl","encodeURI","imageAlt","RegExp","test","replace","patchLinks","$","load","each","_","el","href","attr","startsWith","jwtData","link","jwtLink","isMailOptionsWithHtml","v","sendMail","transporter","sendMailOptions","sendOptions","getSendOptions","pMap","result","getSendOptionsBeforeSend","concurrency","sendConcurrency","Infinity","o","extractEmails","tokenData","getData","patchHtmlBody","trim","text","match","image","expressApp","getOptions","app","express","resolveOptions","Promise","resolve","get","req","res","next","params","onLinkClick","redirect","onBlankImageView","set","send"],"mappings":"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"}