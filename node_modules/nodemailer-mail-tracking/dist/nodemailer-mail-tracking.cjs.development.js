'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var pMap = _interopDefault(require('p-map'));
var cheerio = require('cheerio');
var jwt = _interopDefault(require('jsonwebtoken'));
var express = _interopDefault(require('express'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var recipientKeys = ['to', 'cc', 'bcc'];
var splitByRecipients = function splitByRecipients(options) {
  return recipientKeys.map(function (recipientKey) {
    return options[recipientKey];
  }).map(function (recipient) {
    return patchSendMailOptions(recipient, options);
  }).flat().filter(function (n) {
    return Boolean(n);
  });
};

var joinRecipients = function joinRecipients(recipients) {
  return Array.isArray(recipients) ? recipients.join(', ') : recipients;
};

var patchSendMailOptions = function patchSendMailOptions(recipient, _ref) {
  var to = _ref.to,
      cc = _ref.cc,
      bcc = _ref.bcc,
      options = _objectWithoutPropertiesLoose(_ref, ["to", "cc", "bcc"]);

  var headers = {};
  var toAddress = getRecipientAddress(to);

  if (toAddress) {
    headers.To = joinRecipients(toAddress);
  }

  var ccAddress = getRecipientAddress(cc);

  if (ccAddress) {
    headers.Cc = joinRecipients(ccAddress);
  }

  var bccAddress = getRecipientAddress(bcc);

  if (bccAddress) {
    headers.Bcc = joinRecipients(bccAddress);
  }

  var from = getRecipientAddress(options.from);
  var rcptTo = toArrayString(getRecipientAddress(recipient)) || [];
  return rcptTo.map(function (recipient) {
    return _extends({}, options, {
      headers: _extends({}, options.headers, headers),
      envelope: {
        from: Array.isArray(from) ? from[0] : from,
        to: recipient
      }
    });
  });
};

function getRecipientAddress(recipient) {
  return typeof recipient === 'string' ? recipient : Array.isArray(recipient) ? recipient.map(function (r) {
    return typeof r === 'string' ? r : r.address || undefined;
  }).filter(function (n) {
    return Boolean(n);
  }) : (recipient === null || recipient === void 0 ? void 0 : recipient.address) ? recipient.address : undefined;
}

function toArrayString(value) {
  return typeof value === 'undefined' || Array.isArray(value) ? value : [value];
}

var sign = function sign(options, data) {
  return jwt.sign(_extends({}, data), options.jwtSecret, {
    expiresIn: '1y'
  });
};
var decode = function decode(options, token) {
  try {
    return jwt.verify(token, options.jwtSecret);
  } catch (originalError) {
    var err = new Error('JwtDecodeError');
    err.name = 'JwtDecodeError';
    throw err;
  }
};
function isDecodeError(error) {
  return error && 'name' in error && error.name === 'JwtDecodeError';
}

var addBlankImage = function addBlankImage(options, html, data) {
  var jwtImg = sign(options, data);
  var imgTag = "<img src=\"" + options.baseUrl + "/blank-image/" + encodeURI(jwtImg) + "\"" + (options.imageAlt ? " alt=\"" + options.imageAlt + "\"" : '') + " />";

  if (new RegExp(/<\/body>/).test(html)) {
    html = html.replace(/<\/body>/, imgTag + "</body>");
  } else {
    html = "" + html + imgTag;
  }

  return html;
};
var patchLinks = function patchLinks(options, html, data) {
  var $ = cheerio.load(html);
  $('a').each(function (_, el) {
    var href = $(el).attr('href');

    if (href && href.startsWith('http')) {
      var jwtData = _extends({}, data, {
        link: href
      });

      var jwtLink = sign(options, jwtData);
      $(el).attr('href', options.baseUrl + "/link/" + encodeURI(jwtLink));
    }
  });
  return $.html();
};

function isMailOptionsWithHtml(v) {
  return v.html && typeof v.html === 'string';
}

var sendMail = function sendMail(options, transporter, sendMailOptions) {
  try {
    var _temp5 = function _temp5(_result) {
      if (_exit2) return _result;
      var sendOptions = getSendOptions(options, sendMailOptions);
      return pMap(sendOptions, function (sendOptions) {
        return Promise.resolve(_catch(function () {
          function _temp8() {
            return Promise.resolve(transporter.sendMail(sendOptions)).then(function (result) {
              return {
                result: result,
                sendOptions: sendOptions
              };
            });
          }

          var _temp7 = function () {
            if (options.getSendOptionsBeforeSend) {
              return Promise.resolve(options.getSendOptionsBeforeSend(sendOptions)).then(function (_options$getSendOptio2) {
                sendOptions = _options$getSendOptio2;
              });
            }
          }();

          return _temp7 && _temp7.then ? _temp7.then(_temp8) : _temp8(_temp7);
        }, function (error) {
          return {
            error: error,
            sendOptions: sendOptions
          };
        }));
      }, {
        concurrency: options.sendConcurrency || Infinity
      });
    };

    var _exit2 = false;

    var _temp6 = function () {
      if (!isMailOptionsWithHtml(sendMailOptions)) {
        return _catch(function () {
          function _temp2() {
            return Promise.resolve(transporter.sendMail(sendMailOptions)).then(function (result) {
              _exit2 = true;
              return [{
                result: result,
                sendOptions: sendMailOptions
              }];
            });
          }

          var _temp = function () {
            if (options.getSendOptionsBeforeSend) {
              return Promise.resolve(options.getSendOptionsBeforeSend(sendMailOptions)).then(function (_options$getSendOptio) {
                sendMailOptions = _options$getSendOptio;
              });
            }
          }();

          return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
        }, function (error) {
          _exit2 = true;
          return [{
            error: error,
            sendOptions: sendMailOptions
          }];
        });
      }
    }();

    return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));
  } catch (e) {
    return Promise.reject(e);
  }
};

var getSendOptions = function getSendOptions(options, sendMailOptions) {
  return splitByRecipients(sendMailOptions).map(function (o) {
    var data = {
      recipient: typeof o.envelope.to === 'object' ? o.envelope.to.address : extractEmails(o.envelope.to)
    };

    var tokenData = _extends({}, options.getData(data), data);

    return _extends({}, o, {
      html: patchHtmlBody(options, o.html, tokenData)
    });
  });
};

var patchHtmlBody = function patchHtmlBody(options, html, data) {
  return patchLinks(options, addBlankImage(options, html, data), data).trim();
};

var extractEmails = function extractEmails(text) {
  // d\+1 = "+"
  var result = text.match(/([a-zA-Z0-9._-]+[d+1]?[a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/gi);
  return result && result[0] || '';
};

var image = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"1\" height=\"1\"/>";
function expressApp(getOptions) {
  var app = express();

  var resolveOptions = function resolveOptions() {
    return Promise.resolve(typeof getOptions === 'function' ? getOptions() : getOptions);
  };

  app.get('/link/:jwt', function (req, res, next) {
    try {
      var _temp2 = _catch(function () {
        return Promise.resolve(resolveOptions()).then(function (options) {
          var data = decode(options, req.params.jwt);
          return Promise.resolve(options.onLinkClick(data)).then(function () {
            res.redirect(data.link);
          });
        });
      }, function (err) {
        if (isDecodeError(err)) {
          next();
        } else {
          next(err);
        }
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  });
  app.get('/blank-image/:jwt', function (req, res, next) {
    try {
      var _temp4 = _catch(function () {
        return Promise.resolve(resolveOptions()).then(function (options) {
          var data = decode(options, req.params.jwt);
          return Promise.resolve(options.onBlankImageView(data)).then(function () {
            res.set('Content-Type', 'image/svg+xml');
            res.send(image);
          });
        });
      }, function (err) {
        if (isDecodeError(err)) {
          next();
        } else {
          next(err);
        }
      });

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  });
  return app;
}

exports.expressApp = expressApp;
exports.sendMail = sendMail;
//# sourceMappingURL=nodemailer-mail-tracking.cjs.development.js.map
